{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/core/EntryPoint.sol": {
      "content": "/**\r\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\r\n ** Only one instance required on each chain.\r\n **/\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.12;\r\n\r\n/* solhint-disable avoid-low-level-calls */\r\n/* solhint-disable no-inline-assembly */\r\nimport \"./NonceManager.sol\";\r\nimport \"../utils/Exec.sol\";\r\nimport \"./StakeManager.sol\";\r\nimport \"./SenderCreator.sol\";\r\nimport \"./Helpers.sol\";\r\nimport \"../interfaces/IAccount.sol\";\r\nimport \"../interfaces/IPaymaster.sol\";\r\nimport \"../interfaces/IEntryPoint.sol\";\r\n\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\ncontract EntryPoint is IEntryPoint, StakeManager, NonceManager, ReentrancyGuard {\r\n\r\n    using UserOperationLib for UserOperation;\r\n\r\n    SenderCreator private immutable senderCreator = new SenderCreator();\r\n\r\n    // internal value used during simulation: need to query aggregator.\r\n    address private constant SIMULATE_FIND_AGGREGATOR = address(1);\r\n\r\n    // marker for inner call revert on out of gas\r\n    bytes32 private constant INNER_OUT_OF_GAS = hex'deaddead';\r\n\r\n    uint256 private constant REVERT_REASON_MAX_LEN = 2048;\r\n\r\n    /**\r\n     * for simulation purposes, validateUserOp (and validatePaymasterUserOp) must return this value\r\n     * in case of signature failure, instead of revert.\r\n     */\r\n    uint256 public constant SIG_VALIDATION_FAILED = 1;\r\n\r\n    /**\r\n     * compensate the caller's beneficiary address with the collected fees of all UserOperations.\r\n     * @param beneficiary the address to receive the fees\r\n     * @param amount amount to transfer.\r\n     */\r\n    function _compensate(address payable beneficiary, uint256 amount) internal {\r\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\r\n        (bool success,) = beneficiary.call{value : amount}(\"\");\r\n        require(success, \"AA91 failed send to beneficiary\");\r\n    }\r\n\r\n    /**\r\n     * execute a user op\r\n     * @param opIndex index into the opInfo array\r\n     * @param userOp the userOp to execute\r\n     * @param opInfo the opInfo filled by validatePrepayment for this userOp.\r\n     * @return collected the total amount this userOp paid.\r\n     */\r\n    function _executeUserOp(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory opInfo) private returns (uint256 collected) {\r\n        uint256 preGas = gasleft();\r\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\r\n\r\n        try this.innerHandleOp(userOp.callData, opInfo, context) returns (uint256 _actualGasCost) {\r\n            collected = _actualGasCost;\r\n        } catch {\r\n            bytes32 innerRevertCode;\r\n            assembly {\r\n                returndatacopy(0, 0, 32)\r\n                innerRevertCode := mload(0)\r\n            }\r\n            // handleOps was called with gas limit too low. abort entire bundle.\r\n            if (innerRevertCode == INNER_OUT_OF_GAS) {\r\n                //report paymaster, since if it is not deliberately caused by the bundler,\r\n                // it must be a revert caused by paymaster.\r\n                revert FailedOp(opIndex, \"AA95 out of gas\");\r\n            }\r\n\r\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\r\n            collected = _handlePostOp(opIndex, IPaymaster.PostOpMode.postOpReverted, opInfo, context, actualGas);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a batch of UserOperations.\r\n     * no signature aggregator is used.\r\n     * if any account requires an aggregator (that is, it returned an aggregator when\r\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\r\n     * @param ops the operations to execute\r\n     * @param beneficiary the address to receive the fees\r\n     */\r\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public nonReentrant {\r\n\r\n        uint256 opslen = ops.length;\r\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\r\n\r\n    unchecked {\r\n        for (uint256 i = 0; i < opslen; i++) {\r\n            UserOpInfo memory opInfo = opInfos[i];\r\n            (uint256 validationData, uint256 pmValidationData) = _validatePrepayment(i, ops[i], opInfo);\r\n            _validateAccountAndPaymasterValidationData(i, validationData, pmValidationData, address(0));\r\n        }\r\n\r\n        uint256 collected = 0;\r\n        emit BeforeExecution();\r\n\r\n        for (uint256 i = 0; i < opslen; i++) {\r\n            collected += _executeUserOp(i, ops[i], opInfos[i]);\r\n        }\r\n\r\n        _compensate(beneficiary, collected);\r\n    } //unchecked\r\n    }\r\n\r\n    /**\r\n     * Execute a batch of UserOperation with Aggregators\r\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\r\n     * @param beneficiary the address to receive the fees\r\n     */\r\n    function handleAggregatedOps(\r\n        UserOpsPerAggregator[] calldata opsPerAggregator,\r\n        address payable beneficiary\r\n    ) public nonReentrant {\r\n\r\n        uint256 opasLen = opsPerAggregator.length;\r\n        uint256 totalOps = 0;\r\n        for (uint256 i = 0; i < opasLen; i++) {\r\n            UserOpsPerAggregator calldata opa = opsPerAggregator[i];\r\n            UserOperation[] calldata ops = opa.userOps;\r\n            IAggregator aggregator = opa.aggregator;\r\n\r\n            //address(1) is special marker of \"signature error\"\r\n            require(address(aggregator) != address(1), \"AA96 invalid aggregator\");\r\n\r\n            if (address(aggregator) != address(0)) {\r\n                // solhint-disable-next-line no-empty-blocks\r\n                try aggregator.validateSignatures(ops, opa.signature) {}\r\n                catch {\r\n                    revert SignatureValidationFailed(address(aggregator));\r\n                }\r\n            }\r\n\r\n            totalOps += ops.length;\r\n        }\r\n\r\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\r\n\r\n        emit BeforeExecution();\r\n\r\n        uint256 opIndex = 0;\r\n        for (uint256 a = 0; a < opasLen; a++) {\r\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\r\n            UserOperation[] calldata ops = opa.userOps;\r\n            IAggregator aggregator = opa.aggregator;\r\n\r\n            uint256 opslen = ops.length;\r\n            for (uint256 i = 0; i < opslen; i++) {\r\n                UserOpInfo memory opInfo = opInfos[opIndex];\r\n                (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(opIndex, ops[i], opInfo);\r\n                _validateAccountAndPaymasterValidationData(i, validationData, paymasterValidationData, address(aggregator));\r\n                opIndex++;\r\n            }\r\n        }\r\n\r\n        uint256 collected = 0;\r\n        opIndex = 0;\r\n        for (uint256 a = 0; a < opasLen; a++) {\r\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\r\n            emit SignatureAggregatorChanged(address(opa.aggregator));\r\n            UserOperation[] calldata ops = opa.userOps;\r\n            uint256 opslen = ops.length;\r\n\r\n            for (uint256 i = 0; i < opslen; i++) {\r\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\r\n                opIndex++;\r\n            }\r\n        }\r\n        emit SignatureAggregatorChanged(address(0));\r\n\r\n        _compensate(beneficiary, collected);\r\n    }\r\n\r\n    /// @inheritdoc IEntryPoint\r\n    function simulateHandleOp(UserOperation calldata op, address target, bytes calldata targetCallData) external override {\r\n\r\n        UserOpInfo memory opInfo;\r\n        _simulationOnlyValidations(op);\r\n        (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(0, op, opInfo);\r\n        ValidationData memory data = _intersectTimeRange(validationData, paymasterValidationData);\r\n\r\n        numberMarker();\r\n        uint256 paid = _executeUserOp(0, op, opInfo);\r\n        numberMarker();\r\n        bool targetSuccess;\r\n        bytes memory targetResult;\r\n        if (target != address(0)) {\r\n            (targetSuccess, targetResult) = target.call(targetCallData);\r\n        }\r\n        revert ExecutionResult(opInfo.preOpGas, paid, data.validAfter, data.validUntil, targetSuccess, targetResult);\r\n    }\r\n\r\n\r\n    // A memory copy of UserOp static fields only.\r\n    // Excluding: callData, initCode and signature. Replacing paymasterAndData with paymaster.\r\n    struct MemoryUserOp {\r\n        address sender;\r\n        uint256 nonce;\r\n        uint256 callGasLimit;\r\n        uint256 verificationGasLimit;\r\n        uint256 preVerificationGas;\r\n        address paymaster;\r\n        uint256 maxFeePerGas;\r\n        uint256 maxPriorityFeePerGas;\r\n    }\r\n\r\n    struct UserOpInfo {\r\n        MemoryUserOp mUserOp;\r\n        bytes32 userOpHash;\r\n        uint256 prefund;\r\n        uint256 contextOffset;\r\n        uint256 preOpGas;\r\n    }\r\n\r\n    /**\r\n     * inner function to handle a UserOperation.\r\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\r\n     */\r\n    function innerHandleOp(bytes memory callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\r\n        uint256 preGas = gasleft();\r\n        require(msg.sender == address(this), \"AA92 internal call only\");\r\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\r\n\r\n        uint callGasLimit = mUserOp.callGasLimit;\r\n    unchecked {\r\n        // handleOps was called with gas limit too low. abort entire bundle.\r\n        if (gasleft() < callGasLimit + mUserOp.verificationGasLimit + 5000) {\r\n            assembly {\r\n                mstore(0, INNER_OUT_OF_GAS)\r\n                revert(0, 32)\r\n            }\r\n        }\r\n    }\r\n\r\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\r\n        if (callData.length > 0) {\r\n            bool success = Exec.call(mUserOp.sender, 0, callData, callGasLimit);\r\n            if (!success) {\r\n                bytes memory result = Exec.getReturnData(REVERT_REASON_MAX_LEN);\r\n                if (result.length > 0) {\r\n                    emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\r\n                }\r\n                mode = IPaymaster.PostOpMode.opReverted;\r\n            }\r\n        }\r\n\r\n    unchecked {\r\n        uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\r\n        //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\r\n        return _handlePostOp(0, mode, opInfo, context, actualGas);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * generate a request Id - unique identifier for this request.\r\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\r\n     */\r\n    function getUserOpHash(UserOperation calldata userOp) public view returns (bytes32) {\r\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\r\n    }\r\n\r\n    /**\r\n     * copy general fields from userOp into the memory opInfo structure.\r\n     */\r\n    function _copyUserOpToMemory(UserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\r\n        mUserOp.sender = userOp.sender;\r\n        mUserOp.nonce = userOp.nonce;\r\n        mUserOp.callGasLimit = userOp.callGasLimit;\r\n        mUserOp.verificationGasLimit = userOp.verificationGasLimit;\r\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\r\n        mUserOp.maxFeePerGas = userOp.maxFeePerGas;\r\n        mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\r\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\r\n        if (paymasterAndData.length > 0) {\r\n            require(paymasterAndData.length >= 20, \"AA93 invalid paymasterAndData\");\r\n            mUserOp.paymaster = address(bytes20(paymasterAndData[: 20]));\r\n        } else {\r\n            mUserOp.paymaster = address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\r\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\r\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\r\n     * @param userOp the user operation to validate.\r\n     */\r\n    function simulateValidation(UserOperation calldata userOp) external {\r\n        UserOpInfo memory outOpInfo;\r\n\r\n        _simulationOnlyValidations(userOp);\r\n        (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(0, userOp, outOpInfo);\r\n        StakeInfo memory paymasterInfo = _getStakeInfo(outOpInfo.mUserOp.paymaster);\r\n        StakeInfo memory senderInfo = _getStakeInfo(outOpInfo.mUserOp.sender);\r\n        StakeInfo memory factoryInfo;\r\n        {\r\n            bytes calldata initCode = userOp.initCode;\r\n            address factory = initCode.length >= 20 ? address(bytes20(initCode[0 : 20])) : address(0);\r\n            factoryInfo = _getStakeInfo(factory);\r\n        }\r\n\r\n        ValidationData memory data = _intersectTimeRange(validationData, paymasterValidationData);\r\n        address aggregator = data.aggregator;\r\n        bool sigFailed = aggregator == address(1);\r\n        ReturnInfo memory returnInfo = ReturnInfo(outOpInfo.preOpGas, outOpInfo.prefund,\r\n            sigFailed, data.validAfter, data.validUntil, getMemoryBytesFromOffset(outOpInfo.contextOffset));\r\n\r\n        if (aggregator != address(0) && aggregator != address(1)) {\r\n            AggregatorStakeInfo memory aggregatorInfo = AggregatorStakeInfo(aggregator, _getStakeInfo(aggregator));\r\n            revert ValidationResultWithAggregation(returnInfo, senderInfo, factoryInfo, paymasterInfo, aggregatorInfo);\r\n        }\r\n        revert ValidationResult(returnInfo, senderInfo, factoryInfo, paymasterInfo);\r\n\r\n    }\r\n\r\n    function _getRequiredPrefund(MemoryUserOp memory mUserOp) internal pure returns (uint256 requiredPrefund) {\r\n    unchecked {\r\n        //when using a Paymaster, the verificationGasLimit is used also to as a limit for the postOp call.\r\n        // our security model might call postOp eventually twice\r\n        uint256 mul = mUserOp.paymaster != address(0) ? 3 : 1;\r\n        uint256 requiredGas = mUserOp.callGasLimit + mUserOp.verificationGasLimit * mul + mUserOp.preVerificationGas;\r\n\r\n        requiredPrefund = requiredGas * mUserOp.maxFeePerGas;\r\n    }\r\n    }\r\n\r\n    // create the sender's contract if needed.\r\n    function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\r\n        if (initCode.length != 0) {\r\n            address sender = opInfo.mUserOp.sender;\r\n            if (sender.code.length != 0) revert FailedOp(opIndex, \"AA10 sender already constructed\");\r\n            address sender1 = senderCreator.createSender{gas : opInfo.mUserOp.verificationGasLimit}(initCode);\r\n            if (sender1 == address(0)) revert FailedOp(opIndex, \"AA13 initCode failed or OOG\");\r\n            if (sender1 != sender) revert FailedOp(opIndex, \"AA14 initCode must return sender\");\r\n            if (sender1.code.length == 0) revert FailedOp(opIndex, \"AA15 initCode must create sender\");\r\n            address factory = address(bytes20(initCode[0 : 20]));\r\n            emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get counterfactual sender address.\r\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\r\n     * this method always revert, and returns the address in SenderAddressResult error\r\n     * @param initCode the constructor code to be passed into the UserOperation.\r\n     */\r\n    function getSenderAddress(bytes calldata initCode) public {\r\n        address sender = senderCreator.createSender(initCode);\r\n        revert SenderAddressResult(sender);\r\n    }\r\n\r\n    function _simulationOnlyValidations(UserOperation calldata userOp) internal view {\r\n        // solhint-disable-next-line no-empty-blocks\r\n        try this._validateSenderAndPaymaster(userOp.initCode, userOp.sender, userOp.paymasterAndData) {}\r\n        catch Error(string memory revertReason) {\r\n            if (bytes(revertReason).length != 0) {\r\n                revert FailedOp(0, revertReason);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Called only during simulation.\r\n    * This function always reverts to prevent warm/cold storage differentiation in simulation vs execution.\r\n    */\r\n    function _validateSenderAndPaymaster(bytes calldata initCode, address sender, bytes calldata paymasterAndData) external view {\r\n        if (initCode.length == 0 && sender.code.length == 0) {\r\n            // it would revert anyway. but give a meaningful message\r\n            revert(\"AA20 account not deployed\");\r\n        }\r\n        if (paymasterAndData.length >= 20) {\r\n            address paymaster = address(bytes20(paymasterAndData[0 : 20]));\r\n            if (paymaster.code.length == 0) {\r\n                // it would revert anyway. but give a meaningful message\r\n                revert(\"AA30 paymaster not deployed\");\r\n            }\r\n        }\r\n        // always revert\r\n        revert(\"\");\r\n    }\r\n\r\n    /**\r\n     * call account.validateUserOp.\r\n     * revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\r\n     * decrement account's deposit if needed\r\n     */\r\n    function _validateAccountPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPrefund)\r\n    internal returns (uint256 gasUsedByValidateAccountPrepayment, uint256 validationData) {\r\n    unchecked {\r\n        uint256 preGas = gasleft();\r\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\r\n        address sender = mUserOp.sender;\r\n        _createSenderIfNeeded(opIndex, opInfo, op.initCode);\r\n        address paymaster = mUserOp.paymaster;\r\n        numberMarker();\r\n        uint256 missingAccountFunds = 0;\r\n        if (paymaster == address(0)) {\r\n            uint256 bal = balanceOf(sender);\r\n            missingAccountFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\r\n        }\r\n        try IAccount(sender).validateUserOp{gas : mUserOp.verificationGasLimit}(op, opInfo.userOpHash, missingAccountFunds)\r\n        returns (uint256 _validationData) {\r\n            validationData = _validationData;\r\n        } catch Error(string memory revertReason) {\r\n            revert FailedOp(opIndex, string.concat(\"AA23 reverted: \", revertReason));\r\n        } catch {\r\n            revert FailedOp(opIndex, \"AA23 reverted (or OOG)\");\r\n        }\r\n        if (paymaster == address(0)) {\r\n            DepositInfo storage senderInfo = deposits[sender];\r\n            uint256 deposit = senderInfo.deposit;\r\n            if (requiredPrefund > deposit) {\r\n                revert FailedOp(opIndex, \"AA21 didn't pay prefund\");\r\n            }\r\n            senderInfo.deposit = uint112(deposit - requiredPrefund);\r\n        }\r\n        gasUsedByValidateAccountPrepayment = preGas - gasleft();\r\n    }\r\n    }\r\n\r\n    /**\r\n     * In case the request has a paymaster:\r\n     * Validate paymaster has enough deposit.\r\n     * Call paymaster.validatePaymasterUserOp.\r\n     * Revert with proper FailedOp in case paymaster reverts.\r\n     * Decrement paymaster's deposit\r\n     */\r\n    function _validatePaymasterPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPreFund, uint256 gasUsedByValidateAccountPrepayment)\r\n    internal returns (bytes memory context, uint256 validationData) {\r\n    unchecked {\r\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\r\n        uint256 verificationGasLimit = mUserOp.verificationGasLimit;\r\n        require(verificationGasLimit > gasUsedByValidateAccountPrepayment, \"AA41 too little verificationGas\");\r\n        uint256 gas = verificationGasLimit - gasUsedByValidateAccountPrepayment;\r\n\r\n        address paymaster = mUserOp.paymaster;\r\n        DepositInfo storage paymasterInfo = deposits[paymaster];\r\n        uint256 deposit = paymasterInfo.deposit;\r\n        if (deposit < requiredPreFund) {\r\n            revert FailedOp(opIndex, \"AA31 paymaster deposit too low\");\r\n        }\r\n        paymasterInfo.deposit = uint112(deposit - requiredPreFund);\r\n        try IPaymaster(paymaster).validatePaymasterUserOp{gas : gas}(op, opInfo.userOpHash, requiredPreFund) returns (bytes memory _context, uint256 _validationData){\r\n            context = _context;\r\n            validationData = _validationData;\r\n        } catch Error(string memory revertReason) {\r\n            revert FailedOp(opIndex, string.concat(\"AA33 reverted: \", revertReason));\r\n        } catch {\r\n            revert FailedOp(opIndex, \"AA33 reverted (or OOG)\");\r\n        }\r\n    }\r\n    }\r\n\r\n    /**\r\n     * revert if either account validationData or paymaster validationData is expired\r\n     */\r\n    function _validateAccountAndPaymasterValidationData(uint256 opIndex, uint256 validationData, uint256 paymasterValidationData, address expectedAggregator) internal view {\r\n        (address aggregator, bool outOfTimeRange) = _getValidationData(validationData);\r\n        if (expectedAggregator != aggregator) {\r\n            revert FailedOp(opIndex, \"AA24 signature error\");\r\n        }\r\n        if (outOfTimeRange) {\r\n            revert FailedOp(opIndex, \"AA22 expired or not due\");\r\n        }\r\n        //pmAggregator is not a real signature aggregator: we don't have logic to handle it as address.\r\n        // non-zero address means that the paymaster fails due to some signature check (which is ok only during estimation)\r\n        address pmAggregator;\r\n        (pmAggregator, outOfTimeRange) = _getValidationData(paymasterValidationData);\r\n        if (pmAggregator != address(0)) {\r\n            revert FailedOp(opIndex, \"AA34 signature error\");\r\n        }\r\n        if (outOfTimeRange) {\r\n            revert FailedOp(opIndex, \"AA32 paymaster expired or not due\");\r\n        }\r\n    }\r\n\r\n    function _getValidationData(uint256 validationData) internal view returns (address aggregator, bool outOfTimeRange) {\r\n        if (validationData == 0) {\r\n            return (address(0), false);\r\n        }\r\n        ValidationData memory data = _parseValidationData(validationData);\r\n        // solhint-disable-next-line not-rely-on-time\r\n        outOfTimeRange = block.timestamp > data.validUntil || block.timestamp < data.validAfter;\r\n        aggregator = data.aggregator;\r\n    }\r\n\r\n    /**\r\n     * validate account and paymaster (if defined).\r\n     * also make sure total validation doesn't exceed verificationGasLimit\r\n     * this method is called off-chain (simulateValidation()) and on-chain (from handleOps)\r\n     * @param opIndex the index of this userOp into the \"opInfos\" array\r\n     * @param userOp the userOp to validate\r\n     */\r\n    function _validatePrepayment(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory outOpInfo)\r\n    private returns (uint256 validationData, uint256 paymasterValidationData) {\r\n\r\n        uint256 preGas = gasleft();\r\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\r\n        _copyUserOpToMemory(userOp, mUserOp);\r\n        outOpInfo.userOpHash = getUserOpHash(userOp);\r\n\r\n        // validate all numeric values in userOp are well below 128 bit, so they can safely be added\r\n        // and multiplied without causing overflow\r\n        uint256 maxGasValues = mUserOp.preVerificationGas | mUserOp.verificationGasLimit | mUserOp.callGasLimit |\r\n        userOp.maxFeePerGas | userOp.maxPriorityFeePerGas;\r\n        require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\");\r\n\r\n        uint256 gasUsedByValidateAccountPrepayment;\r\n        (uint256 requiredPreFund) = _getRequiredPrefund(mUserOp);\r\n        (gasUsedByValidateAccountPrepayment, validationData) = _validateAccountPrepayment(opIndex, userOp, outOpInfo, requiredPreFund);\r\n\r\n        if (!_validateAndUpdateNonce(mUserOp.sender, mUserOp.nonce)) {\r\n            revert FailedOp(opIndex, \"AA25 invalid account nonce\");\r\n        }\r\n\r\n        //a \"marker\" where account opcode validation is done and paymaster opcode validation is about to start\r\n        // (used only by off-chain simulateValidation)\r\n        numberMarker();\r\n\r\n        bytes memory context;\r\n        if (mUserOp.paymaster != address(0)) {\r\n            (context, paymasterValidationData) = _validatePaymasterPrepayment(opIndex, userOp, outOpInfo, requiredPreFund, gasUsedByValidateAccountPrepayment);\r\n        }\r\n    unchecked {\r\n        uint256 gasUsed = preGas - gasleft();\r\n\r\n        if (userOp.verificationGasLimit < gasUsed) {\r\n            revert FailedOp(opIndex, \"AA40 over verificationGasLimit\");\r\n        }\r\n        outOpInfo.prefund = requiredPreFund;\r\n        outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\r\n        outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\r\n    }\r\n    }\r\n\r\n    /**\r\n     * process post-operation.\r\n     * called just after the callData is executed.\r\n     * if a paymaster is defined and its validation returned a non-empty context, its postOp is called.\r\n     * the excess amount is refunded to the account (or paymaster - if it was used in the request)\r\n     * @param opIndex index in the batch\r\n     * @param mode - whether is called from innerHandleOp, or outside (postOpReverted)\r\n     * @param opInfo userOp fields and info collected during validation\r\n     * @param context the context returned in validatePaymasterUserOp\r\n     * @param actualGas the gas used so far by this user operation\r\n     */\r\n    function _handlePostOp(uint256 opIndex, IPaymaster.PostOpMode mode, UserOpInfo memory opInfo, bytes memory context, uint256 actualGas) private returns (uint256 actualGasCost) {\r\n        uint256 preGas = gasleft();\r\n    unchecked {\r\n        address refundAddress;\r\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\r\n        uint256 gasPrice = getUserOpGasPrice(mUserOp);\r\n\r\n        address paymaster = mUserOp.paymaster;\r\n        if (paymaster == address(0)) {\r\n            refundAddress = mUserOp.sender;\r\n        } else {\r\n            refundAddress = paymaster;\r\n            if (context.length > 0) {\r\n                actualGasCost = actualGas * gasPrice;\r\n                if (mode != IPaymaster.PostOpMode.postOpReverted) {\r\n                    IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost);\r\n                } else {\r\n                    // solhint-disable-next-line no-empty-blocks\r\n                    try IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost) {}\r\n                    catch Error(string memory reason) {\r\n                        revert FailedOp(opIndex, string.concat(\"AA50 postOp reverted: \", reason));\r\n                    }\r\n                    catch {\r\n                        revert FailedOp(opIndex, \"AA50 postOp revert\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        actualGas += preGas - gasleft();\r\n        actualGasCost = actualGas * gasPrice;\r\n        if (opInfo.prefund < actualGasCost) {\r\n            revert FailedOp(opIndex, \"AA51 prefund below actualGasCost\");\r\n        }\r\n        uint256 refund = opInfo.prefund - actualGasCost;\r\n        _incrementDeposit(refundAddress, refund);\r\n        bool success = mode == IPaymaster.PostOpMode.opSucceeded;\r\n        emit UserOperationEvent(opInfo.userOpHash, mUserOp.sender, mUserOp.paymaster, mUserOp.nonce, success, actualGasCost, actualGas);\r\n    } // unchecked\r\n    }\r\n\r\n    /**\r\n     * the gas price this UserOp agrees to pay.\r\n     * relayer/block builder might submit the TX with higher priorityFee, but the user should not\r\n     */\r\n    function getUserOpGasPrice(MemoryUserOp memory mUserOp) internal view returns (uint256) {\r\n    unchecked {\r\n        uint256 maxFeePerGas = mUserOp.maxFeePerGas;\r\n        uint256 maxPriorityFeePerGas = mUserOp.maxPriorityFeePerGas;\r\n        if (maxFeePerGas == maxPriorityFeePerGas) {\r\n            //legacy mode (for networks that don't support basefee opcode)\r\n            return maxFeePerGas;\r\n        }\r\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\r\n    }\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function getOffsetOfMemoryBytes(bytes memory data) internal pure returns (uint256 offset) {\r\n        assembly {offset := data}\r\n    }\r\n\r\n    function getMemoryBytesFromOffset(uint256 offset) internal pure returns (bytes memory data) {\r\n        assembly {data := offset}\r\n    }\r\n\r\n    //place the NUMBER opcode in the code.\r\n    // this is used as a marker during simulation, as this OP is completely banned from the simulated code of the\r\n    // account and paymaster.\r\n    function numberMarker() internal view {\r\n        assembly {mstore(0, number())}\r\n    }\r\n}\r\n\r\n"
    },
    "contracts/core/Helpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.12;\r\n\r\n/* solhint-disable no-inline-assembly */\r\n\r\n/**\r\n * returned data from validateUserOp.\r\n * validateUserOp returns a uint256, with is created by `_packedValidationData` and parsed by `_parseValidationData`\r\n * @param aggregator - address(0) - the account validated the signature by itself.\r\n *              address(1) - the account failed to validate the signature.\r\n *              otherwise - this is an address of a signature aggregator that must be used to validate the signature.\r\n * @param validAfter - this UserOp is valid only after this timestamp.\r\n * @param validaUntil - this UserOp is valid only up to this timestamp.\r\n */\r\n    struct ValidationData {\r\n        address aggregator;\r\n        uint48 validAfter;\r\n        uint48 validUntil;\r\n    }\r\n\r\n//extract sigFailed, validAfter, validUntil.\r\n// also convert zero validUntil to type(uint48).max\r\n    function _parseValidationData(uint validationData) pure returns (ValidationData memory data) {\r\n        address aggregator = address(uint160(validationData));\r\n        uint48 validUntil = uint48(validationData >> 160);\r\n        if (validUntil == 0) {\r\n            validUntil = type(uint48).max;\r\n        }\r\n        uint48 validAfter = uint48(validationData >> (48 + 160));\r\n        return ValidationData(aggregator, validAfter, validUntil);\r\n    }\r\n\r\n// intersect account and paymaster ranges.\r\n    function _intersectTimeRange(uint256 validationData, uint256 paymasterValidationData) pure returns (ValidationData memory) {\r\n        ValidationData memory accountValidationData = _parseValidationData(validationData);\r\n        ValidationData memory pmValidationData = _parseValidationData(paymasterValidationData);\r\n        address aggregator = accountValidationData.aggregator;\r\n        if (aggregator == address(0)) {\r\n            aggregator = pmValidationData.aggregator;\r\n        }\r\n        uint48 validAfter = accountValidationData.validAfter;\r\n        uint48 validUntil = accountValidationData.validUntil;\r\n        uint48 pmValidAfter = pmValidationData.validAfter;\r\n        uint48 pmValidUntil = pmValidationData.validUntil;\r\n\r\n        if (validAfter < pmValidAfter) validAfter = pmValidAfter;\r\n        if (validUntil > pmValidUntil) validUntil = pmValidUntil;\r\n        return ValidationData(aggregator, validAfter, validUntil);\r\n    }\r\n\r\n/**\r\n * helper to pack the return value for validateUserOp\r\n * @param data - the ValidationData to pack\r\n */\r\n    function _packValidationData(ValidationData memory data) pure returns (uint256) {\r\n        return uint160(data.aggregator) | (uint256(data.validUntil) << 160) | (uint256(data.validAfter) << (160 + 48));\r\n    }\r\n\r\n/**\r\n * helper to pack the return value for validateUserOp, when not using an aggregator\r\n * @param sigFailed - true for signature failure, false for success\r\n * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\r\n * @param validAfter first timestamp this UserOperation is valid\r\n */\r\n    function _packValidationData(bool sigFailed, uint48 validUntil, uint48 validAfter) pure returns (uint256) {\r\n        return (sigFailed ? 1 : 0) | (uint256(validUntil) << 160) | (uint256(validAfter) << (160 + 48));\r\n    }\r\n\r\n/**\r\n * keccak function over calldata.\r\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\r\n */\r\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\r\n        assembly {\r\n            let mem := mload(0x40)\r\n            let len := data.length\r\n            calldatacopy(mem, data.offset, len)\r\n            ret := keccak256(mem, len)\r\n        }\r\n    }\r\n\r\n"
    },
    "contracts/core/NonceManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.12;\r\n\r\nimport \"../interfaces/IEntryPoint.sol\";\r\n\r\n/**\r\n * nonce management functionality\r\n */\r\ncontract NonceManager is INonceManager {\r\n\r\n    /**\r\n     * The next valid sequence number for a given nonce key.\r\n     */\r\n    mapping(address => mapping(uint192 => uint256)) public nonceSequenceNumber;\r\n\r\n    function getNonce(address sender, uint192 key)\r\n    public view override returns (uint256 nonce) {\r\n        return nonceSequenceNumber[sender][key] | (uint256(key) << 64);\r\n    }\r\n\r\n    // allow an account to manually increment its own nonce.\r\n    // (mainly so that during construction nonce can be made non-zero,\r\n    // to \"absorb\" the gas cost of first nonce increment to 1st transaction (construction),\r\n    // not to 2nd transaction)\r\n    function incrementNonce(uint192 key) public override {\r\n        nonceSequenceNumber[msg.sender][key]++;\r\n    }\r\n\r\n    /**\r\n     * validate nonce uniqueness for this account.\r\n     * called just after validateUserOp()\r\n     */\r\n    function _validateAndUpdateNonce(address sender, uint256 nonce) internal returns (bool) {\r\n\r\n        uint192 key = uint192(nonce >> 64);\r\n        uint64 seq = uint64(nonce);\r\n        return nonceSequenceNumber[sender][key]++ == seq;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/core/SenderCreator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.12;\r\n\r\n/**\r\n * helper contract for EntryPoint, to call userOp.initCode from a \"neutral\" address,\r\n * which is explicitly not the entryPoint itself.\r\n */\r\ncontract SenderCreator {\r\n\r\n    /**\r\n     * call the \"initCode\" factory to create and return the sender account address\r\n     * @param initCode the initCode value from a UserOp. contains 20 bytes of factory address, followed by calldata\r\n     * @return sender the returned address of the created account, or zero address on failure.\r\n     */\r\n    function createSender(bytes calldata initCode) external returns (address sender) {\r\n        address factory = address(bytes20(initCode[0 : 20]));\r\n        bytes memory initCallData = initCode[20 :];\r\n        bool success;\r\n        /* solhint-disable no-inline-assembly */\r\n        assembly {\r\n            success := call(gas(), factory, 0, add(initCallData, 0x20), mload(initCallData), 0, 32)\r\n            sender := mload(0)\r\n        }\r\n        if (!success) {\r\n            sender = address(0);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/StakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity ^0.8.12;\r\n\r\nimport \"../interfaces/IStakeManager.sol\";\r\n\r\n/* solhint-disable avoid-low-level-calls */\r\n/* solhint-disable not-rely-on-time */\r\n/**\r\n * manage deposits and stakes.\r\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\r\n * stake is value locked for at least \"unstakeDelay\" by a paymaster.\r\n */\r\nabstract contract StakeManager is IStakeManager {\r\n\r\n    /// maps paymaster to their deposits and stakes\r\n    mapping(address => DepositInfo) public deposits;\r\n\r\n    /// @inheritdoc IStakeManager\r\n    function getDepositInfo(address account) public view returns (DepositInfo memory info) {\r\n        return deposits[account];\r\n    }\r\n\r\n    // internal method to return just the stake info\r\n    function _getStakeInfo(address addr) internal view returns (StakeInfo memory info) {\r\n        DepositInfo storage depositInfo = deposits[addr];\r\n        info.stake = depositInfo.stake;\r\n        info.unstakeDelaySec = depositInfo.unstakeDelaySec;\r\n    }\r\n\r\n    /// return the deposit (for gas payment) of the account\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return deposits[account].deposit;\r\n    }\r\n\r\n    receive() external payable {\r\n        depositTo(msg.sender);\r\n    }\r\n\r\n    function _incrementDeposit(address account, uint256 amount) internal {\r\n        DepositInfo storage info = deposits[account];\r\n        uint256 newAmount = info.deposit + amount;\r\n        require(newAmount <= type(uint112).max, \"deposit overflow\");\r\n        info.deposit = uint112(newAmount);\r\n    }\r\n\r\n    /**\r\n     * add to the deposit of the given account\r\n     */\r\n    function depositTo(address account) public payable {\r\n        _incrementDeposit(account, msg.value);\r\n        DepositInfo storage info = deposits[account];\r\n        emit Deposited(account, info.deposit);\r\n    }\r\n\r\n    /**\r\n     * add to the account's stake - amount and delay\r\n     * any pending unstake is first cancelled.\r\n     * @param unstakeDelaySec the new lock duration before the deposit can be withdrawn.\r\n     */\r\n    function addStake(uint32 unstakeDelaySec) public payable {\r\n        DepositInfo storage info = deposits[msg.sender];\r\n        require(unstakeDelaySec > 0, \"must specify unstake delay\");\r\n        require(unstakeDelaySec >= info.unstakeDelaySec, \"cannot decrease unstake time\");\r\n        uint256 stake = info.stake + msg.value;\r\n        require(stake > 0, \"no stake specified\");\r\n        require(stake <= type(uint112).max, \"stake overflow\");\r\n        deposits[msg.sender] = DepositInfo(\r\n            info.deposit,\r\n            true,\r\n            uint112(stake),\r\n            unstakeDelaySec,\r\n            0\r\n        );\r\n        emit StakeLocked(msg.sender, stake, unstakeDelaySec);\r\n    }\r\n\r\n    /**\r\n     * attempt to unlock the stake.\r\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\r\n     */\r\n    function unlockStake() external {\r\n        DepositInfo storage info = deposits[msg.sender];\r\n        require(info.unstakeDelaySec != 0, \"not staked\");\r\n        require(info.staked, \"already unstaking\");\r\n        uint48 withdrawTime = uint48(block.timestamp) + info.unstakeDelaySec;\r\n        info.withdrawTime = withdrawTime;\r\n        info.staked = false;\r\n        emit StakeUnlocked(msg.sender, withdrawTime);\r\n    }\r\n\r\n\r\n    /**\r\n     * withdraw from the (unlocked) stake.\r\n     * must first call unlockStake and wait for the unstakeDelay to pass\r\n     * @param withdrawAddress the address to send withdrawn value.\r\n     */\r\n    function withdrawStake(address payable withdrawAddress) external {\r\n        DepositInfo storage info = deposits[msg.sender];\r\n        uint256 stake = info.stake;\r\n        require(stake > 0, \"No stake to withdraw\");\r\n        require(info.withdrawTime > 0, \"must call unlockStake() first\");\r\n        require(info.withdrawTime <= block.timestamp, \"Stake withdrawal is not due\");\r\n        info.unstakeDelaySec = 0;\r\n        info.withdrawTime = 0;\r\n        info.stake = 0;\r\n        emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\r\n        (bool success,) = withdrawAddress.call{value : stake}(\"\");\r\n        require(success, \"failed to withdraw stake\");\r\n    }\r\n\r\n    /**\r\n     * withdraw from the deposit.\r\n     * @param withdrawAddress the address to send withdrawn value.\r\n     * @param withdrawAmount the amount to withdraw.\r\n     */\r\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external {\r\n        DepositInfo storage info = deposits[msg.sender];\r\n        require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\r\n        info.deposit = uint112(info.deposit - withdrawAmount);\r\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\r\n        (bool success,) = withdrawAddress.call{value : withdrawAmount}(\"\");\r\n        require(success, \"failed to withdraw\");\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.12;\r\n\r\nimport \"./UserOperation.sol\";\r\n\r\ninterface IAccount {\r\n\r\n    /**\r\n     * Validate user's signature and nonce\r\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\r\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\r\n     * This allows making a \"simulation call\" without a valid signature\r\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\r\n     *\r\n     * @dev Must validate caller is the entryPoint.\r\n     *      Must validate the signature and nonce\r\n     * @param userOp the operation that is about to be executed.\r\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\r\n     * @param missingAccountFunds missing funds on the account's deposit in the entrypoint.\r\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\r\n     *      The excess is left as a deposit in the entrypoint, for future calls.\r\n     *      can be withdrawn anytime using \"entryPoint.withdrawTo()\"\r\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\r\n     * @return validationData packaged ValidationData structure. use `_packValidationData` and `_unpackValidationData` to encode and decode\r\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\r\n     *         otherwise, an address of an \"authorizer\" contract.\r\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\r\n     *      <6-byte> validAfter - first timestamp this operation is valid\r\n     *      If an account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\r\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\r\n     */\r\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\r\n    external returns (uint256 validationData);\r\n}\r\n"
    },
    "contracts/interfaces/IAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.12;\r\n\r\nimport \"./UserOperation.sol\";\r\n\r\n/**\r\n * Aggregated Signatures validator.\r\n */\r\ninterface IAggregator {\r\n\r\n    /**\r\n     * validate aggregated signature.\r\n     * revert if the aggregated signature does not match the given list of operations.\r\n     */\r\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature) external view;\r\n\r\n    /**\r\n     * validate signature of a single userOp\r\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\r\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\r\n     * @param userOp the userOperation received from the user.\r\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\r\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\r\n     */\r\n    function validateUserOpSignature(UserOperation calldata userOp)\r\n    external view returns (bytes memory sigForUserOp);\r\n\r\n    /**\r\n     * aggregate multiple signatures into a single value.\r\n     * This method is called off-chain to calculate the signature to pass with handleOps()\r\n     * bundler MAY use optimized custom code perform this aggregation\r\n     * @param userOps array of UserOperations to collect the signatures from.\r\n     * @return aggregatedSignature the aggregated signature\r\n     */\r\n    function aggregateSignatures(UserOperation[] calldata userOps) external view returns (bytes memory aggregatedSignature);\r\n}\r\n"
    },
    "contracts/interfaces/IEntryPoint.sol": {
      "content": "/**\r\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\r\n ** Only one instance required on each chain.\r\n **/\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.12;\r\n\r\n/* solhint-disable avoid-low-level-calls */\r\n/* solhint-disable no-inline-assembly */\r\n/* solhint-disable reason-string */\r\n\r\nimport \"./UserOperation.sol\";\r\nimport \"./IStakeManager.sol\";\r\nimport \"./IAggregator.sol\";\r\nimport \"./INonceManager.sol\";\r\n\r\ninterface IEntryPoint is IStakeManager, INonceManager {\r\n\r\n    /***\r\n     * An event emitted after each successful request\r\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\r\n     * @param sender - the account that generates this request.\r\n     * @param paymaster - if non-null, the paymaster that pays for this request.\r\n     * @param nonce - the nonce value from the request.\r\n     * @param success - true if the sender transaction succeeded, false if reverted.\r\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation.\r\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution).\r\n     */\r\n    event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed);\r\n\r\n    /**\r\n     * account \"sender\" was deployed.\r\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\r\n     * @param sender the account that is deployed\r\n     * @param factory the factory used to deploy this account (in the initCode)\r\n     * @param paymaster the paymaster used by this UserOp\r\n     */\r\n    event AccountDeployed(bytes32 indexed userOpHash, address indexed sender, address factory, address paymaster);\r\n\r\n    /**\r\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length\r\n     * @param userOpHash the request unique identifier.\r\n     * @param sender the sender of this request\r\n     * @param nonce the nonce used in the request\r\n     * @param revertReason - the return bytes from the (reverted) call to \"callData\".\r\n     */\r\n    event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason);\r\n\r\n    /**\r\n     * an event emitted by handleOps(), before starting the execution loop.\r\n     * any event emitted before this event, is part of the validation.\r\n     */\r\n    event BeforeExecution();\r\n\r\n    /**\r\n     * signature aggregator used by the following UserOperationEvents within this bundle.\r\n     */\r\n    event SignatureAggregatorChanged(address indexed aggregator);\r\n\r\n    /**\r\n     * a custom revert error of handleOps, to identify the offending op.\r\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\r\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\r\n     *  @param reason - revert reason\r\n     *      The string starts with a unique code \"AAmn\", where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\r\n     *      so a failure can be attributed to the correct entity.\r\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\r\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\r\n     */\r\n    error FailedOp(uint256 opIndex, string reason);\r\n\r\n    /**\r\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\r\n     */\r\n    error SignatureValidationFailed(address aggregator);\r\n\r\n    /**\r\n     * Successful result from simulateValidation.\r\n     * @param returnInfo gas and time-range returned values\r\n     * @param senderInfo stake information about the sender\r\n     * @param factoryInfo stake information about the factory (if any)\r\n     * @param paymasterInfo stake information about the paymaster (if any)\r\n     */\r\n    error ValidationResult(ReturnInfo returnInfo,\r\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo);\r\n\r\n    /**\r\n     * Successful result from simulateValidation, if the account returns a signature aggregator\r\n     * @param returnInfo gas and time-range returned values\r\n     * @param senderInfo stake information about the sender\r\n     * @param factoryInfo stake information about the factory (if any)\r\n     * @param paymasterInfo stake information about the paymaster (if any)\r\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\r\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\r\n     */\r\n    error ValidationResultWithAggregation(ReturnInfo returnInfo,\r\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo,\r\n        AggregatorStakeInfo aggregatorInfo);\r\n\r\n    /**\r\n     * return value of getSenderAddress\r\n     */\r\n    error SenderAddressResult(address sender);\r\n\r\n    /**\r\n     * return value of simulateHandleOp\r\n     */\r\n    error ExecutionResult(uint256 preOpGas, uint256 paid, uint48 validAfter, uint48 validUntil, bool targetSuccess, bytes targetResult);\r\n\r\n    //UserOps handled, per aggregator\r\n    struct UserOpsPerAggregator {\r\n        UserOperation[] userOps;\r\n\r\n        // aggregator address\r\n        IAggregator aggregator;\r\n        // aggregated signature\r\n        bytes signature;\r\n    }\r\n\r\n    /**\r\n     * Execute a batch of UserOperation.\r\n     * no signature aggregator is used.\r\n     * if any account requires an aggregator (that is, it returned an aggregator when\r\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\r\n     * @param ops the operations to execute\r\n     * @param beneficiary the address to receive the fees\r\n     */\r\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) external;\r\n\r\n    /**\r\n     * Execute a batch of UserOperation with Aggregators\r\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\r\n     * @param beneficiary the address to receive the fees\r\n     */\r\n    function handleAggregatedOps(\r\n        UserOpsPerAggregator[] calldata opsPerAggregator,\r\n        address payable beneficiary\r\n    ) external;\r\n\r\n    /**\r\n     * generate a request Id - unique identifier for this request.\r\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\r\n     */\r\n    function getUserOpHash(UserOperation calldata userOp) external view returns (bytes32);\r\n\r\n    /**\r\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\r\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\r\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\r\n     * @param userOp the user operation to validate.\r\n     */\r\n    function simulateValidation(UserOperation calldata userOp) external;\r\n\r\n    /**\r\n     * gas and return values during simulation\r\n     * @param preOpGas the gas used for validation (including preValidationGas)\r\n     * @param prefund the required prefund for this operation\r\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\r\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\r\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\r\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\r\n     */\r\n    struct ReturnInfo {\r\n        uint256 preOpGas;\r\n        uint256 prefund;\r\n        bool sigFailed;\r\n        uint48 validAfter;\r\n        uint48 validUntil;\r\n        bytes paymasterContext;\r\n    }\r\n\r\n    /**\r\n     * returned aggregated signature info.\r\n     * the aggregator returned by the account, and its current stake.\r\n     */\r\n    struct AggregatorStakeInfo {\r\n        address aggregator;\r\n        StakeInfo stakeInfo;\r\n    }\r\n\r\n    /**\r\n     * Get counterfactual sender address.\r\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\r\n     * this method always revert, and returns the address in SenderAddressResult error\r\n     * @param initCode the constructor code to be passed into the UserOperation.\r\n     */\r\n    function getSenderAddress(bytes memory initCode) external;\r\n\r\n\r\n    /**\r\n     * simulate full execution of a UserOperation (including both validation and target execution)\r\n     * this method will always revert with \"ExecutionResult\".\r\n     * it performs full validation of the UserOperation, but ignores signature error.\r\n     * an optional target address is called after the userop succeeds, and its value is returned\r\n     * (before the entire call is reverted)\r\n     * Note that in order to collect the the success/failure of the target call, it must be executed\r\n     * with trace enabled to track the emitted events.\r\n     * @param op the UserOperation to simulate\r\n     * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\r\n     *        are set to the return from that call.\r\n     * @param targetCallData callData to pass to target address\r\n     */\r\n    function simulateHandleOp(UserOperation calldata op, address target, bytes calldata targetCallData) external;\r\n}\r\n\r\n"
    },
    "contracts/interfaces/INonceManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.12;\r\n\r\ninterface INonceManager {\r\n\r\n    /**\r\n     * Return the next nonce for this sender.\r\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\r\n     * But UserOp with different keys can come with arbitrary order.\r\n     *\r\n     * @param sender the account address\r\n     * @param key the high 192 bit of the nonce\r\n     * @return nonce a full nonce to pass for next UserOp with this sender.\r\n     */\r\n    function getNonce(address sender, uint192 key)\r\n    external view returns (uint256 nonce);\r\n\r\n    /**\r\n     * Manually increment the nonce of the sender.\r\n     * This method is exposed just for completeness..\r\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\r\n     * as the EntryPoint will update the nonce regardless.\r\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\r\n     * UserOperations will not pay extra for the first transaction with a given key.\r\n     */\r\n    function incrementNonce(uint192 key) external;\r\n}\r\n"
    },
    "contracts/interfaces/IPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.12;\r\n\r\nimport \"./UserOperation.sol\";\r\n\r\n/**\r\n * the interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\r\n * a paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\r\n */\r\ninterface IPaymaster {\r\n\r\n    enum PostOpMode {\r\n        opSucceeded, // user op succeeded\r\n        opReverted, // user op reverted. still has to pay for gas.\r\n        postOpReverted //user op succeeded, but caused postOp to revert. Now it's a 2nd call, after user's op was deliberately reverted.\r\n    }\r\n\r\n    /**\r\n     * payment validation: check if paymaster agrees to pay.\r\n     * Must verify sender is the entryPoint.\r\n     * Revert to reject this request.\r\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted)\r\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\r\n     * @param userOp the user operation\r\n     * @param userOpHash hash of the user's request data.\r\n     * @param maxCost the maximum cost of this transaction (based on maximum gas and gas price from userOp)\r\n     * @return context value to send to a postOp\r\n     *      zero length to signify postOp is not required.\r\n     * @return validationData signature and time-range of this operation, encoded the same as the return value of validateUserOperation\r\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\r\n     *         otherwise, an address of an \"authorizer\" contract.\r\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\r\n     *      <6-byte> validAfter - first timestamp this operation is valid\r\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\r\n     */\r\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\r\n    external returns (bytes memory context, uint256 validationData);\r\n\r\n    /**\r\n     * post-operation handler.\r\n     * Must verify sender is the entryPoint\r\n     * @param mode enum with the following options:\r\n     *      opSucceeded - user operation succeeded.\r\n     *      opReverted  - user op reverted. still has to pay for gas.\r\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\r\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\r\n     * @param context - the context value returned by validatePaymasterUserOp\r\n     * @param actualGasCost - actual gas used so far (without this postOp call).\r\n     */\r\n    function postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external;\r\n}\r\n"
    },
    "contracts/interfaces/IStakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity ^0.8.12;\r\n\r\n/**\r\n * manage deposits and stakes.\r\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\r\n * stake is value locked for at least \"unstakeDelay\" by the staked entity.\r\n */\r\ninterface IStakeManager {\r\n\r\n    event Deposited(\r\n        address indexed account,\r\n        uint256 totalDeposit\r\n    );\r\n\r\n    event Withdrawn(\r\n        address indexed account,\r\n        address withdrawAddress,\r\n        uint256 amount\r\n    );\r\n\r\n    /// Emitted when stake or unstake delay are modified\r\n    event StakeLocked(\r\n        address indexed account,\r\n        uint256 totalStaked,\r\n        uint256 unstakeDelaySec\r\n    );\r\n\r\n    /// Emitted once a stake is scheduled for withdrawal\r\n    event StakeUnlocked(\r\n        address indexed account,\r\n        uint256 withdrawTime\r\n    );\r\n\r\n    event StakeWithdrawn(\r\n        address indexed account,\r\n        address withdrawAddress,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @param deposit the entity's deposit\r\n     * @param staked true if this entity is staked.\r\n     * @param stake actual amount of ether staked for this entity.\r\n     * @param unstakeDelaySec minimum delay to withdraw the stake.\r\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\r\n     * @dev sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\r\n     *    and the rest fit into a 2nd cell.\r\n     *    112 bit allows for 10^15 eth\r\n     *    48 bit for full timestamp\r\n     *    32 bit allows 150 years for unstake delay\r\n     */\r\n    struct DepositInfo {\r\n        uint112 deposit;\r\n        bool staked;\r\n        uint112 stake;\r\n        uint32 unstakeDelaySec;\r\n        uint48 withdrawTime;\r\n    }\r\n\r\n    //API struct used by getStakeInfo and simulateValidation\r\n    struct StakeInfo {\r\n        uint256 stake;\r\n        uint256 unstakeDelaySec;\r\n    }\r\n\r\n    /// @return info - full deposit information of given account\r\n    function getDepositInfo(address account) external view returns (DepositInfo memory info);\r\n\r\n    /// @return the deposit (for gas payment) of the account\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * add to the deposit of the given account\r\n     */\r\n    function depositTo(address account) external payable;\r\n\r\n    /**\r\n     * add to the account's stake - amount and delay\r\n     * any pending unstake is first cancelled.\r\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\r\n     */\r\n    function addStake(uint32 _unstakeDelaySec) external payable;\r\n\r\n    /**\r\n     * attempt to unlock the stake.\r\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\r\n     */\r\n    function unlockStake() external;\r\n\r\n    /**\r\n     * withdraw from the (unlocked) stake.\r\n     * must first call unlockStake and wait for the unstakeDelay to pass\r\n     * @param withdrawAddress the address to send withdrawn value.\r\n     */\r\n    function withdrawStake(address payable withdrawAddress) external;\r\n\r\n    /**\r\n     * withdraw from the deposit.\r\n     * @param withdrawAddress the address to send withdrawn value.\r\n     * @param withdrawAmount the amount to withdraw.\r\n     */\r\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;\r\n}\r\n"
    },
    "contracts/interfaces/UserOperation.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.12;\r\n\r\n/* solhint-disable no-inline-assembly */\r\n\r\nimport {calldataKeccak} from \"../core/Helpers.sol\";\r\n\r\n/**\r\n * User Operation struct\r\n * @param sender the sender account of this request.\r\n     * @param nonce unique value the sender uses to verify it is not a replay.\r\n     * @param initCode if set, the account contract will be created by this constructor/\r\n     * @param callData the method call to execute on this account.\r\n     * @param callGasLimit the gas limit passed to the callData method call.\r\n     * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\r\n     * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\r\n     * @param maxFeePerGas same as EIP-1559 gas parameter.\r\n     * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\r\n     * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\r\n     * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\r\n     */\r\n    struct UserOperation {\r\n\r\n        address sender;\r\n        uint256 nonce;\r\n        bytes initCode;\r\n        bytes callData;\r\n        uint256 callGasLimit;\r\n        uint256 verificationGasLimit;\r\n        uint256 preVerificationGas;\r\n        uint256 maxFeePerGas;\r\n        uint256 maxPriorityFeePerGas;\r\n        bytes paymasterAndData;\r\n        bytes signature;\r\n    }\r\n\r\n/**\r\n * Utility functions helpful when working with UserOperation structs.\r\n */\r\nlibrary UserOperationLib {\r\n\r\n    function getSender(UserOperation calldata userOp) internal pure returns (address) {\r\n        address data;\r\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\r\n        assembly {data := calldataload(userOp)}\r\n        return address(uint160(data));\r\n    }\r\n\r\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\r\n    // pay above what he signed for.\r\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\r\n    unchecked {\r\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\r\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\r\n        if (maxFeePerGas == maxPriorityFeePerGas) {\r\n            //legacy mode (for networks that don't support basefee opcode)\r\n            return maxFeePerGas;\r\n        }\r\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\r\n    }\r\n    }\r\n\r\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\r\n        address sender = getSender(userOp);\r\n        uint256 nonce = userOp.nonce;\r\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\r\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\r\n        uint256 callGasLimit = userOp.callGasLimit;\r\n        uint256 verificationGasLimit = userOp.verificationGasLimit;\r\n        uint256 preVerificationGas = userOp.preVerificationGas;\r\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\r\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\r\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\r\n\r\n        return abi.encode(\r\n            sender, nonce,\r\n            hashInitCode, hashCallData,\r\n            callGasLimit, verificationGasLimit, preVerificationGas,\r\n            maxFeePerGas, maxPriorityFeePerGas,\r\n            hashPaymasterAndData\r\n        );\r\n    }\r\n\r\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\r\n        return keccak256(pack(userOp));\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n"
    },
    "contracts/utils/Exec.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity >=0.7.5 <0.9.0;\r\n\r\n// solhint-disable no-inline-assembly\r\n\r\n/**\r\n * Utility functions helpful when making different kinds of contract calls in Solidity.\r\n */\r\nlibrary Exec {\r\n\r\n    function call(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        uint256 txGas\r\n    ) internal returns (bool success) {\r\n        assembly {\r\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function staticcall(\r\n        address to,\r\n        bytes memory data,\r\n        uint256 txGas\r\n    ) internal view returns (bool success) {\r\n        assembly {\r\n            success := staticcall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function delegateCall(\r\n        address to,\r\n        bytes memory data,\r\n        uint256 txGas\r\n    ) internal returns (bool success) {\r\n        assembly {\r\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    // get returned data from last call or calldelegate\r\n    function getReturnData(uint256 maxLen) internal pure returns (bytes memory returnData) {\r\n        assembly {\r\n            let len := returndatasize()\r\n            if gt(len, maxLen) {\r\n                len := maxLen\r\n            }\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, add(len, 0x20)))\r\n            mstore(ptr, len)\r\n            returndatacopy(add(ptr, 0x20), 0, len)\r\n            returnData := ptr\r\n        }\r\n    }\r\n\r\n    // revert with explicit byte array (probably reverted info from call)\r\n    function revertWithData(bytes memory returnData) internal pure {\r\n        assembly {\r\n            revert(add(returnData, 32), mload(returnData))\r\n        }\r\n    }\r\n\r\n    function callAndRevert(address to, bytes memory data, uint256 maxLen) internal {\r\n        bool success = call(to,0,data,gasleft());\r\n        if (!success) {\r\n            revertWithData(getReturnData(maxLen));\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}